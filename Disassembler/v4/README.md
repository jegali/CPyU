# The GUI version
The next step in the creation of the disassembler module was the integration of the command line version into a contemporary graphical user interface. For this the already presented user interface created in QT Designer was used. I made some changes to the source code of the disassembler, which will be discussed in the next sections.

## The Interface
The interface has all the features that I consider useful at the moment. There is a minimal hex-viewer at the top left, the possibility to load object or assembler files and - very important - the disassemble button. Depending on the selected function the output takes place with clock cycles, occupation and/or address mode.

![Disassembler_CMD](/images/disassembler.png)

So, pretty much of the functionality already shown on the command line can be found here.

## App structure
As already discussed, the application consists of two parts. There is the UI file generated by Qt Designer, which has been translated into python source text using pyuic. And there is the main.py file that starts the program.

Here are again the contents of the file main.py:

```bash
import sys

from PyQt6 import QtCore, QtGui, QtWidgets

from disassemblerWindow import Ui_DisassemblerWindow


def main():
    app = QtWidgets.QApplication(sys.argv)
    main = QtWidgets.QMainWindow()
    disasm = Ui_DisassemblerWindow()
    disasm.setupUi(main)
    main.show()
    sys.exit(app.exec())

if __name__ == '__main__':
    main()
```

The class that encapsulates the graphical interface is named UI_DisassemblerWindow and is called from the program code of the main.py class.

## The UI class
UI_DisassemblerView is the file converted by the program pyuic with the description of the interface. In this file I have integrated the code of the disassembler. Similar to the description of the console program, I will also go into some specifics of the source code so that it can be better understood. The main entry point in this class is the method setupUi.

```bash
   def setupUi(self, DisassemblerWindow):
        DisassemblerWindow.setObjectName("DisassemblerWindow")
        DisassemblerWindow.resize(800, 810)
        font = QtGui.QFont()
        font.setFamily("Courier New")
        font.setPointSize(10)
        
        self.centralwidget = QtWidgets.QWidget(DisassemblerWindow)
        self.centralwidget.setObjectName("centralwidget")
        
        self.plainTextEdit = QtWidgets.QPlainTextEdit(self.centralwidget)
        self.plainTextEdit.setGeometry(QtCore.QRect(20, 40, 361, 181))
        self.plainTextEdit.setObjectName("txtEditCode")
        self.plainTextEdit.setReadOnly(True)
        self.plainTextEdit.setFont(font)
        self.plainTextEdit.appendPlainText("paste hex source here or load hex-dump / rom-file")
        
        self.plainTextEdit_2 = QtWidgets.QPlainTextEdit(self.centralwidget)
        self.plainTextEdit_2.setGeometry(QtCore.QRect(410, 40, 361, 181))
        self.plainTextEdit_2.setObjectName("txtEditSymbol")
        
        self.cmdLoadCode = QtWidgets.QPushButton(self.centralwidget, clicked = lambda: self.loadCode())
        self.cmdLoadCode.setGeometry(QtCore.QRect(20, 240, 75, 24))
        self.cmdLoadCode.setObjectName("cmdLoadCode")
        
        self.pushButton_2 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_2.setGeometry(QtCore.QRect(410, 240, 121, 24))
        self.pushButton_2.setObjectName("cmdLoadTable")
        
        self.txtStartAddress = QtWidgets.QLineEdit(self.centralwidget)
        self.txtStartAddress.setGeometry(QtCore.QRect(160, 290, 113, 22))
        self.txtStartAddress.setObjectName("txtStartAddress")
        self.txtStartAddress.setText("0x" + hex(self.start_address)[2:].upper().zfill(4))
        self.txtStartAddress.returnPressed.connect(self.reformatView)
        self.txtStartAddress.setValidator(self.hex_validator)

        self.txtFromAddress = QtWidgets.QLineEdit(self.centralwidget)
        self.txtFromAddress.setGeometry(QtCore.QRect(160, 320, 113, 22))
        self.txtFromAddress.setObjectName("txtFromAddress")
        
        self.txtEndAddress = QtWidgets.QLineEdit(self.centralwidget)
        self.txtEndAddress.setGeometry(QtCore.QRect(160, 350, 113, 22))
        self.txtEndAddress.setObjectName("txtEndAddress")
        
        self.lblStartAddress = QtWidgets.QLabel(self.centralwidget)
        self.lblStartAddress.setGeometry(QtCore.QRect(30, 290, 120, 16))
        self.lblStartAddress.setObjectName("lblStartAddress")
        
        self.lblFromAddress = QtWidgets.QLabel(self.centralwidget)
        self.lblFromAddress.setGeometry(QtCore.QRect(30, 320, 131, 16))
        self.lblFromAddress.setObjectName("lblFromAddress")
        
        self.lblEndAddress = QtWidgets.QLabel(self.centralwidget)
        self.lblEndAddress.setGeometry(QtCore.QRect(30, 350, 49, 16))
        self.lblEndAddress.setObjectName("lblEndAddress")
        
        self.chkDecodeIllegalOpcodes = QtWidgets.QCheckBox(self.centralwidget)
        self.chkDecodeIllegalOpcodes.setGeometry(QtCore.QRect(420, 290, 180, 20))
        self.chkDecodeIllegalOpcodes.setObjectName("chkDecodeIllegalOpcodes")
        
        self.chkShowCycles = QtWidgets.QCheckBox(self.centralwidget)
        self.chkShowCycles.setGeometry(QtCore.QRect(420, 310, 180, 20))
        self.chkShowCycles.setObjectName("chkShowCycles")
        
        self.cmdDisassemble = QtWidgets.QPushButton(self.centralwidget, clicked = lambda: self.disassemble())
        self.cmdDisassemble.setGeometry(QtCore.QRect(680, 380, 75, 24))
        self.cmdDisassemble.setObjectName("cmdDisassemble")
        
        self.plainTextEdit_3 = QtWidgets.QPlainTextEdit(self.centralwidget)
        self.plainTextEdit_3.setGeometry(QtCore.QRect(20, 420, 751, 361))
        self.plainTextEdit_3.setObjectName("txtEditDisasm")
        self.plainTextEdit_3.setReadOnly(True)
        self.plainTextEdit_3.setFont(font)
        
        self.lblCodeView = QtWidgets.QLabel(self.centralwidget)
        self.lblCodeView.setGeometry(QtCore.QRect(20, 10, 71, 16))
        self.lblCodeView.setObjectName("lblCodeView")

        self.lblDisasmView = QtWidgets.QLabel(self.centralwidget)
        self.lblDisasmView.setGeometry(QtCore.QRect(20, 390, 100, 16))
        self.lblDisasmView.setObjectName("lblDisasmView")
        
        self.lblSymbolTable = QtWidgets.QLabel(self.centralwidget)
        self.lblSymbolTable.setGeometry(QtCore.QRect(410, 10, 131, 16))
        self.lblSymbolTable.setObjectName("lblSymbolTable")
        
        self.cmdSaveToFile = QtWidgets.QPushButton(self.centralwidget, clicked = lambda: self.saveDisassembled())
        self.cmdSaveToFile.setGeometry(QtCore.QRect(590, 380, 75, 24))
        self.cmdSaveToFile.setObjectName("cmdSaveToFile")
        
        self.chkShowDescription = QtWidgets.QCheckBox(self.centralwidget)
        self.chkShowDescription.setGeometry(QtCore.QRect(420, 330, 180, 20))
        self.chkShowDescription.setObjectName("chkShowDescription")

        self.chkShowMode = QtWidgets.QCheckBox(self.centralwidget)
        self.chkShowMode.setGeometry(QtCore.QRect(420, 350, 180, 20))
        self.chkShowMode.setObjectName("chkShowMode")


        DisassemblerWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(DisassemblerWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 22))
        self.menubar.setObjectName("menubar")
        DisassemblerWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(DisassemblerWindow)
        self.statusbar.setObjectName("statusbar")
        DisassemblerWindow.setStatusBar(self.statusbar)

        self.retranslateUi(DisassemblerWindow)
        QtCore.QMetaObject.connectSlotsByName(DisassemblerWindow)
```

I can't explain every single line of the surface description - it certainly makes sense to consult a book for that - but the sticking points that weren't obvious to me and generated effort in researching and implementing them should be briefly addressed.

### Button clicks
What I didn't take into account when creating the interface in the designer was that clicks on buttons result in event handling. Surely it is possible to handle this via the designer, but for now this process is still manual. Fortunately, it is relatively easy to use an event handling method via the "clicked" parameter.
In the following code snippet you can see that here when you click the button the method "loadCode" is called.

```bash
self.cmdLoadCode = QtWidgets.QPushButton(self.centralwidget, clicked = lambda: self.loadCode())
self.cmdLoadCode.setGeometry(QtCore.QRect(20, 240, 75, 24))
self.cmdLoadCode.setObjectName("cmdLoadCode")
```

Analogous to this example, you can proceed with every button on the graphical user interface.


### Using Dialogues
In console applications, a file can be quickly opened for reading or writing. In graphical applications, you usually go through a file selection dialog. Since this is not automatically created when the interface is created, some research was necessary here as well.

```bash
    def loadCode(self):
        # File Dialog liefert die angeklickte Datei zurück
        fname = QFileDialog.getOpenFileName(None, "Open File", ".\\", "Rom Files (*.rom)")
        if fname[0]:
            # decodieren der Datei
            self.read_file(fname[0])
```

If the user selected a file and pressed Open, the filename is submitted in a variable called fname[0]. So, if this variable is filled with a valid value, the file can be opened, read and parsed.

```bash
    def read_file(self, file):
        input_file = open(file, "rb")
        # Die Datei in ein Bytearray umwandeln und abspeichern
        self.code_array = bytearray(input_file.read())
        self.fill_code_view(self.code_array)
```
Saving a disassemblat is also done via the dialog integrated in Qt. The method "saveDisassembled" shows how the saving is done.

```bash
    def saveDisassembled(self):
        fileName, _ = QFileDialog.getSaveFileName(None, 
            "Save File", "", "All Files(*);;Text Files(*.txt)")
        
        if fileName:
            with open(fileName, 'w') as f:
                f.write(self.plainTextEdit_3.toPlainText())
            self.fileName = fileName   
```

### The Code view
The read object or assembly file is to be displayed in the code view in the usual format of a hex viewer. This means that the memory address is displayed on the left, followed by eight bytes in hex format.

![Code_View](/images/code-view.png)

The fill_code_view method is responsible for formatting. Here, as long as the memory address is smaller than 65536 (#FFFF), chunks of 8 bytes length are read and displayed as hex values.

```bash
    def fill_code_view(self, code_array):
        address = self.start_address
        blocksize = 8
        self.plainTextEdit.clear()
        for chunk in range(0,len(code_array), blocksize):
            if address < 65536:
                address_str = hex(address)[2:].upper().zfill(4) + ": "
                self.plainTextEdit.appendPlainText(address_str + code_array[chunk:chunk+blocksize].hex(" "))
            address += blocksize
        txtCursor = self.plainTextEdit.textCursor()
        txtCursor.setPosition(0)
        self.plainTextEdit.setTextCursor(txtCursor)

```

Very helpful here was the Python method "hex", which not only can represent values in hex mode, but also can represent spaces between hex values by hex(" "). This eliminates the need for a complicated separation of the input values. In addition, the "zfill" method can be used to insert leading zeros into the output.

### Additional Options 
As already thought in the command line version, the graphical variant of the disassembler offers the possibility to display clock cycles, address mode and description of the instruction. This was realized via checkboxes in the user interface. These checkboxes are queried and displayed in the method "writeOptions".

```bash
    def writeOptions(self, opcode):
        options = ""
        if self.chkShowCycles.isChecked(): 
            options = options + (str(self.operations[opcode][0]) + "\t")
        if self.chkShowMode.isChecked():
            options = options + "{:<20}".format(self.operations[opcode][3]) + "\t"
        if self.chkShowDescription.isChecked():
            options = options + "{:<30}".format(self.operations[opcode][4])
        if len(options) > 0:
            options = ";" + options

        return options
```

### Output to the text box
The output to the text box is not fundamentally different from the output to the console. Only the commands for a screen output are different from dss appending strings to the display in the text box.

```bash
    def disassemble(self):
        # nur, wenn etwas im Buffer steht, wird decodiert
        if self.code_array:
            # Startadresse aus dem Textfeld
            address = int(self.txtStartAddress.text(),0)
            self.plainTextEdit_3.clear()
            # Schleifenzähler
            byte_to_decode = 0
            last_byte = len(self.code_array)

            while byte_to_decode < last_byte:
                # Zeile zusammenbauen
                # Schreibe die Adresse
                line_to_write = hex(address)[2:].upper().zfill(4) + "- \t"
                
                # Decodiere den Opcode 
                opcode = int(self.code_array[byte_to_decode])
                # Byte in Hex umwandeln
                # 0x entfernen, entweder durch replace() oder [2:]
                # in Großbuchstaben umwandeln
                # mit führenden Nullen auffüllen, falls notwendig
                hexcode = hex(opcode)[2:].upper().zfill(2)
                # und in die Zeile schreiben
                line_to_write = line_to_write + (hexcode + " ")
                
                address += 1
                byte_to_decode += 1
                
                # Die Adressmodi Implizit und Akkumulator bestehen nur 
                # aus einem Byte und haben keine Operanden oder Adressen
                if self.operations[opcode][2] == "imp":
                    line_to_write = line_to_write + ("    \t\t" + "{:<15}".format(self.operations[opcode][1]) + "\t")
                    line_to_write = line_to_write + self.writeOptions(opcode)
                    self.plainTextEdit_3.appendPlainText(line_to_write)
                    continue    # nächster Befehl

                if self.operations[opcode][2] == "acc":
                    line_to_write = line_to_write + ("    \t\t" + "{:<15}".format(self.operations[opcode][1]) + "\t")
                    line_to_write = line_to_write + self.writeOptions(opcode)
                    self.plainTextEdit_3.appendPlainText(line_to_write)
                    continue    # nächster Befehl
                                
                
                # nach dem Opcode den (ersten) Operanden lesen
                bytecode = int(self.code_array[byte_to_decode])
                operand = bytecode
                hexcode = hex(operand)[2:].upper().zfill(2)
                # und in die Datei schreiben
                line_to_write = line_to_write + (hexcode + " ")
                address += 1
                byte_to_decode += 1
                
                # nun den Befehl auswerten
                # Immediate
                if self.operations[opcode][2] == "imm":
                    line_to_write = line_to_write + ("\t\t" + "{:<15}".format(self.operations[opcode][1] + " #$" + hexcode) + "\t")
                    line_to_write = line_to_write + self.writeOptions(opcode)
                    self.plainTextEdit_3.appendPlainText(line_to_write)
                    continue

                # Relative
                if self.operations[opcode][2] == "rel":
                    line_to_write = line_to_write + ("\t\t" + "{:<15}".format(self.operations[opcode][1] + " $" + hexcode) + "\t")
                    line_to_write = line_to_write + self.writeOptions(opcode)
                    self.plainTextEdit_3.appendPlainText(line_to_write)
                    continue

                # Zero Page
                if self.operations[opcode][2] == "zpg":
                    line_to_write = line_to_write + ("\t\t" + "{:<15}".format(self.operations[opcode][1] + " $" + hexcode) + "\t")
                    line_to_write = line_to_write + self.writeOptions(opcode)
                    self.plainTextEdit_3.appendPlainText(line_to_write)
                    continue

                # Zero Page, X indexed
                if self.operations[opcode][2] == "zpx":
                    line_to_write = line_to_write + ("\t\t" + "{:<15}".format(self.operations[opcode][1] + " $" + hexcode + ",X") + "\t")
                    line_to_write = line_to_write + self.writeOptions(opcode)
                    self.plainTextEdit_3.appendPlainText(line_to_write)
                    continue

                # Zero Page, Y indexed
                if self.operations[opcode][2] == "zpy":
                    line_to_write = line_to_write + ("\t\t" + "{:<15}".format(self.operations[opcode][1] + " $" + hexcode + ",Y") + "\t")
                    line_to_write = line_to_write + self.writeOptions(opcode)
                    self.plainTextEdit_3.appendPlainText(line_to_write)
                    continue

                # X indexed, indirect
                if self.operations[opcode][2] == "inx":
                    line_to_write = line_to_write + ("\t\t" + "{:<15}".format(self.operations[opcode][1] + " $(" + hexcode + ",X)") + "\t")
                    line_to_write = line_to_write + self.writeOptions(opcode)
                    self.plainTextEdit_3.appendPlainText(line_to_write)
                    continue

                # indirect, Y indexed
                if self.operations[opcode][2] == "iny":
                    line_to_write = line_to_write + ("\t\t" + "{:<15}".format(self.operations[opcode][1] + " $(" + hexcode + "),Y") + "\t")
                    line_to_write = line_to_write + self.writeOptions(opcode)
                    self.plainTextEdit_3.appendPlainText(line_to_write)
                    continue

                # Nun sind noch alle Befehle übrig, die ein weiteres Byte
                # (also ingesamt 3 Bytes) für den Befehl beanspruchen

                # nach dem Opcode den (zweiten) Operanden lesen
                bytecode = int(self.code_array[byte_to_decode])
                operand2 = bytecode
                hexcode2 = hex(operand2)[2:].upper().zfill(2)
                # und in die Datei schreiben
                hexcode = hexcode2 + hexcode
                line_to_write = line_to_write + (hexcode2)
                address += 1
                byte_to_decode += 1

                # nun den Befehl auswerten
                # Indirect
                if self.operations[opcode][2] == "ind":
                    line_to_write = line_to_write + ("\t\t" + "{:<15}".format(self.operations[opcode][1] + " $(" + hexcode + ")") + "\t")
                    line_to_write = line_to_write + self.writeOptions(opcode)
                    self.plainTextEdit_3.appendPlainText(line_to_write)
                    continue

                # Absolute
                if self.operations[opcode][2] == "abs":
                    line_to_write = line_to_write + ("\t\t" + "{:<15}".format(self.operations[opcode][1] + " $" + hexcode) + "\t")
                    line_to_write = line_to_write + self.writeOptions(opcode)
                    self.plainTextEdit_3.appendPlainText(line_to_write)
                    continue
                
                # Absolute, X indexed
                if self.operations[opcode][2] == "abx":
                    line_to_write = line_to_write + ("\t\t" + "{:<15}".format(self.operations[opcode][1] + " $" + hexcode + ",X") + "\t")
                    line_to_write = line_to_write + self.writeOptions(opcode)
                    self.plainTextEdit_3.appendPlainText(line_to_write)
                    continue

                # Absolute, Y indexed
                if self.operations[opcode][2] == "aby":
                    line_to_write = line_to_write + ("\t\t" + "{:<15}".format(self.operations[opcode][1] + " $" + hexcode + ",Y") + "\t")
                    line_to_write = line_to_write + self.writeOptions(opcode)
                    self.plainTextEdit_3.appendPlainText(line_to_write)
                    continue    


                self.plainTextEdit_3.appendPlainText(line_to_write)
        
        txtCursor = self.plainTextEdit_3.textCursor()
        txtCursor.setPosition(0)
        self.plainTextEdit_3.setTextCursor(txtCursor)
```

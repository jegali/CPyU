# Form implementation generated from reading ui file '.\assembler.ui'
#
# Created by: PyQt6 UI code generator 6.4.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6.QtWidgets import QFileDialog, QMessageBox
from PyQt6.Qsci import *

class Ui_AssemblerWindow(object):

    sourcecode = list()
    linenumber = 1

    label_dict = dict()
    label_list = list()

    opcode_dict = dict()
    opcode_list = list()

    directive_dict = dict()
    directive_list = list()

    # List of valid opcodes and their hex value for the matching address mode
    # address modes are: 
    # Implicit | Accumulator | Immediate | Absolute | Absolute, X Indexed | Absolute, Y Indexed
    # Zero Page | Zero Page, X Indexed | Zero Page, Y Indexed | Indirect | 
    # X Indexed, Indirect | Indirect, Y Indexed | Relative


    validopcodes = { 
        'ADC':[  -1,  -1,0x69,0x6d,0x7d,0x79,0x65,0x75,  -1,  -1,0x61,0x71,  -1],
        'AND':[  -1,  -1,0x29,0x2d,0x3d,0x39,0x25,0x35,  -1,  -1,0x21,0x31,  -1],
        'ASL':[  -1,0x0a,  -1,0x0e,0x1e,  -1,0x06,0x16,  -1,  -1,  -1,  -1,  -1],
        'BCC':[  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,0x90],
        'BCS':[  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,0xb0],
        'BEQ':[  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,0xf0],
        'BIT':[  -1,  -1,  -1,0x2c,  -1,  -1,0x24,  -1,  -1,  -1,  -1,  -1,  -1],
        'BMI':[  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,0x30],
        'BNE':[  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,0xd0],
        'BPL':[  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,0x10],
        'BRK':[0x00,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'BVC':[  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,0x50],
        'BVS':[  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,0x70],
        'CLC':[0x18,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'CLD':[0xd8,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'CLI':[0x58,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'CLV':[0xb8,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'CMP':[  -1,  -1,0xc9,0xcd,0xdd,0xd9,0xc5,0xd5,  -1,  -1,0xc1,0xd1,  -1],
        'CPX':[  -1,  -1,0xe0,0xec,  -1,  -1,0xe4,  -1,  -1,  -1,  -1,  -1,  -1],
        'CPY':[  -1,  -1,0xc0,0xcc,  -1,  -1,0xc4,  -1,  -1,  -1,  -1,  -1,  -1],
        'DEC':[  -1,  -1,  -1,0xce,0xde,  -1,0xc6,0xd6,  -1,  -1,  -1,  -1,  -1],
        'DEX':[0xca,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'DEY':[0x88,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'EOR':[  -1,  -1,0x49,0x4d,0x5d,0x59,0x45,0x55,  -1,  -1,0x41,0x51,  -1],
        'INC':[  -1,  -1,  -1,0xee,0xfe,  -1,0xe6,0xf6,  -1,  -1,  -1,  -1,  -1],
        'INX':[0xe8,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'INY':[0xc8,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'JMP':[  -1,  -1,  -1,0x4c,  -1,  -1,  -1,  -1,  -1,0x6c,  -1,  -1,  -1],
        'JSR':[  -1,  -1,  -1,0x20,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'LDA':[  -1,  -1,0xa9,0xad,0xbd,0xb9,0xa5,0xb5,  -1,  -1,0xa1,0xb1,  -1],
        'LDX':[  -1,  -1,0xa2,0xae,  -1,0xbe,0xa6,  -1,0xb6,  -1,  -1,  -1,  -1],
        'LDY':[  -1,  -1,0xa0,0xac,0xbc,  -1,0xa4,0xb4,  -1,  -1,  -1,  -1,  -1],
        'LSR':[  -1,0x4a,  -1,0x4e,0x5e,  -1,0x46,0x56,  -1,  -1,  -1,  -1,  -1],
        'NOP':[0xea,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'ORA':[  -1,  -1,0x09,0x0d,0x1d,0x19,0x05,0x15,  -1,  -1,0x01,0x11,  -1],
        'PHA':[0x48,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'PHP':[0x08,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'PLA':[0x68,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'PLP':[0x28,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'ROL':[  -1,0x2a,  -1,0x2e,0x3e,  -1,0x26,0x36,  -1,  -1,  -1,  -1,  -1],
        'ROR':[  -1,0x6a,  -1,0x6e,0x7e,  -1,0x66,0x76,  -1,  -1,  -1,  -1,  -1],
        'RTI':[0x40,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'RTS':[0x60,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'SBC':[  -1,  -1,0xe9,0xed,0xfd,0xf9,0xe5,0xf5,  -1,  -1,0xe1,0xf1,  -1],
        'SEC':[0x38,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'SED':[0xf8,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'SEI':[0x78,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'STA':[  -1,  -1,  -1,0x8d,0x9d,0x99,0x85,0x95,  -1,  -1,0x81,0x91,  -1],
        'STX':[  -1,  -1,  -1,0x8e,  -1,  -1,0x86,  -1,0x96,  -1,  -1,  -1,  -1],
        'STY':[  -1,  -1,  -1,0x8c,  -1,  -1,0x84,0x94,  -1,  -1,  -1,  -1,  -1],
        'TAX':[0xaa,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'TAY':[0xa8,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'TSX':[0xba,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'TXA':[0x8a,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'TXS':[0x9a,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1],
        'TYA':[0x98,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1,  -1]
        }


    validdirectives = {".DB", ".DW", ".DDW", ".DQW", ".STR", ".ORG", ".LE", ".BE", ".EQU", ".END"}


    implicitopcodes = ["BRK","CLC","CLD","CLI","CLV","DEX","DEY","INX",
                       "INY","NOP","PHA","PHP","PHX","PHY","PLA","PLP",
                       "PLX","PLY","RTI","RTS","SEC","SED","SEI","TAX",
                       "TAY","TRB","TSB","TSX","TXA","TXS","TYA"]
    
    accumulatoropcodes = ["ASL","DEA","DEC","INA","INC","LSR","ROL","ROR"]

    immediateopcodes = ["ADC","AND","BIT","CMP","CPX","CPY","EOR","LDA",
                        "LDX","LDY","ORA","SBC"]

    zeropageopcodes = ["ADC","AND","ASL","BIT","CMP","CPX","CPY","DEC",
                       "EOR","INC","LDA","LDX","LDY","LSR","ORA","ROL",
                       "ROR","SBC","STA","STX","STY","STZ","TRB","TSB"]
        
    absoluteopcodes = ["ADC","AND","ASL","BIT","CMP","CPX","CPY","DEC",
                       "EOR","INC","JMP","JSR","LDA","LDX","LDY","LSR",
                       "ORA","ROL","ROR","SBC","STA","STX","STY","STZ",
                       "TRB","TSB"]

    absolutexopcodes = ["ADC","AND","ASL","BIT","CMP","DEC","EOR","INC",
                        "LDA","LSR","ORA","ROL","ROR","SBC","STA","STZ",
                        "LDY"]

    absoluteyopcodes = ["ADC","AND","CMP","EOR","LDA","LDX","ORA","SBC",
                        "STA"]

    zeropagexopcodes = ["ADC","AND","CMP","EOR","LDA","DEC","BIT","ASL",
                        "LDY","ORA","SBC","STA","STY","ROR","ROL","LSR",
                        "INC","STZ"]

    zeropageyopcodes = ["LDX","STX"]
                          
    relativeopcodes = ["BMI","BNE","BPL","BRA","BVC","BVS","BCC","BCS","BEQ"]
        
    zeropageindexedindirectxopcodes = ["ADC","AND","CMP","EOR","LDA","ORA","SBC","STA"]

    zeropageindexedindirectyopcodes = ["ADC","AND","CMP","EOR","LDA","ORA","SBC","STA"]

    zeropageindirectopcodes = ["ADC","AND","CMP","EOR","LDA","ORA","SBC","STA"]

    address_mode = {
    #   ROR A
        'Accumulator': (1, [ ('ASL', '0A'), ('LSR', '4A'), ('ROL', '2A'), ('ROR', '6A') ] ),

    #   SBC #$44
        'Immediate':   (2, [ ('ADC', '69'), ('AND', '29'), ('LDY', 'A0'), ('LDX', 'A2'), 
                            ('LDA', 'A9'), ('EOR', '49'), ('CPY', 'C0'), ('CPX', 'E0'), 
                            ('CMP', 'C9'), ('ORA', '09'), ('SBC', 'E9') ] ),

    #   SBC $44
        'Zero Page':   (2, [ ('ADC', '65'), ('AND', '25'), ('ASL', '06'), ('BIT', '24'), 
                            ('LSR', '46'), ('LDY', 'A4'), ('LDX', 'A6'), ('LDA', 'A5'), 
                            ('INC', 'E6'), ('EOR', '45'), ('DEC', 'C6'), ('CPY', 'C4'), 
                            ('CPX', 'E4'), ('CMP', 'C5'), ('ORA', '05'), ('ROL', '26'),
                            ('ROR', '66'), ('SBC', 'E5'), ('STA', '85'), ('STX', '86'),
                            ('STY', '84') ] ),

    #   SBC $44,X
        'Zero Page,X': (2, [ ('ADC', '75'), ('AND', '35'), ('ASL', '16'), ('CMP', 'D5'),
                            ('DEC', 'D6'), ('EOR', '55'), ('INC', 'F6'), ('LDA', 'B5'),
                            ('LDY', 'B4'), ('LSR', '56'), ('ORA', '15'), ('ROL', '36'),
                            ('ROR', '76'), ('SBC', 'F5'), ('STA', '95'), ('STY', '94') ] ),

    #   STX $44,Y
        'Zero Page,Y': (2, [ ('LDX', 'B6'), ('STX', '96') ] ),

    #   STX $4400
        'Absolute':    (3, [ ('ADC', '6D'), ('AND', '2D'), ('ASL', '0E'), ('BIT', '2C'), 
                            ('CMP', 'CD'), ('CPX', 'EC'), ('CPY', 'CC'), ('DEC', 'CE'),
                            ('EOR', '4D'), ('INC', 'EE'), ('JMP', '4C'), ('JSR', '20'),
                            ('LDA', 'AD'), ('LDX', 'AE'), ('LDY', 'AC'), ('LSR', '4E'),
                            ('ORA', '0D'), ('ROL', '2E'), ('ROR', '6E'), ('SBC', 'ED'),
                            ('STA', '8D'), ('STX', '8E'), ('STY', '8C') ] ),

    #   STA $4400,X
        'Absolute,X':  (3, [ ('ADC', '7D'), ('AND', '3D'), ('ASL', '1E'), ('CMP', 'DD'),
                            ('DEC', 'DE'), ('EOR', '5D'), ('INC', 'FE'), ('LDA', 'BD'),
                            ('LDY', 'BC'), ('LSR', '5E'), ('ORA', '1D'), ('ROL', '3E'),
                            ('SBC', 'FD'), ('STA', '9D') ] ),

    #   STA $4400,Y
        'Absolute,Y':  (3, [ ('ADC', '79'), ('AND', '39'), ('CMP', 'D9'), ('EOR', '59'),
                            ('LDA', 'B9'), ('LDX', 'BE'), ('ORA', '19'), ('SBC', 'F9'),
                            ('STA', '99') ] ),

    #   JMP ($5597)
        'Indirect':    (3, [ ('JMP', '6C') ] ),

    #   LDA ($44,X)
        'Indirect,X':  (2, [ ('ADC', '61'), ('AND', '21'), ('CMP', 'C1'), ('EOR', '41'),
                            ('LDA', 'A1'), ('ORA', '01'), ('SBC', 'E1'), ('STA', '81') ] ),

    #   LDA ($44),Y
        'Indirect,Y':  (2, [ ('ADC', '71'), ('AND', '31'), ('CMP', 'D1'), ('EOR', '51'),
                            ('LDA', 'B1'), ('ORA', '11'), ('SBC', 'F1'), ('STA', '91') ] ),

    #   BRK
        'Implied':     (1, [ ('BRK', '00'), ('CLC', '18'), ('SEC', '38'), ('CLI', '58'),
                            ('SEI', '78'), ('CLV', 'B8'), ('CLD', 'D8'), ('SED', 'F8'),
                            ('TAX', 'AA'), ('TXA', '8A'), ('DEX', 'CA'), ('INX', 'E8'),
                            ('TAY', 'A8'), ('TYA', '98'), ('DEY', '88'), ('INY', 'C8'),
                            ('TXS', '9A'), ('TSX', 'BA'), ('PHA', '48'), ('PLA', '68'),
                            ('PHP', '08'), ('PLP', '28'), ('NOP', 'EA'), ('RTI', '40'),
                            ('RTS', '60') ] )
    }


    address_mode_patterns = {
        '\#\$[0-9A-F]{2}': 'Immediate', '\$[0-9A-F]{2}': 'Zero Page', '\$[0-9A-F]{2},X': 'Zero Page,X', 
        '\$[0-9A-F]{2},Y': 'Zero Page,Y', '\$[0-9A-F]{4}': 'Absolute', '\$[0-9A-F]{4},X': 'Absolute,X',
        '\$[0-9A-F]{4},Y': 'Absolute,Y', '\(\$[0-9A-F]{4}\)': 'Indirect', '\(\$[0-9A-F]{2},X\)': 'Indirect,X',
        '\(\$[0-9A-F]{2}\),Y': 'Indirect,Y'
    }



    def setupUi(self, AssemblerWindow):
        AssemblerWindow.setObjectName("AssemblerWindow")
        AssemblerWindow.resize(1000, 812)
        font = QtGui.QFont()
        font.setFamily("Courier New")
        font.setPointSize(11)

        self.centralwidget = QtWidgets.QWidget(AssemblerWindow)
        self.centralwidget.setObjectName("centralwidget")

        self.cmdSaveObjectcode = QtWidgets.QPushButton(self.centralwidget)
        self.cmdSaveObjectcode.setGeometry(QtCore.QRect(610, 330, 141, 24))
        self.cmdSaveObjectcode.setObjectName("cmdSaveObjectcode")

        self.cmdSaveAsmToFile = QtWidgets.QPushButton(self.centralwidget)
        self.cmdSaveAsmToFile.setGeometry(QtCore.QRect(320, 390, 75, 24))
        self.cmdSaveAsmToFile.setObjectName("cmdSaveAsmToFile")

        self.txtEditAssembler = QtWidgets.QPlainTextEdit(self.centralwidget)
        self.txtEditAssembler.setGeometry(QtCore.QRect(20, 420, 481, 321))
        self.txtEditAssembler.setLineWrapMode(QtWidgets.QPlainTextEdit.LineWrapMode.NoWrap)
        self.txtEditAssembler.setReadOnly(False)
        self.txtEditAssembler.setObjectName("txtEditAssembler")

        self.lblObjectCode = QtWidgets.QLabel(self.centralwidget)
        self.lblObjectCode.setGeometry(QtCore.QRect(610, 10, 131, 16))
        self.lblObjectCode.setObjectName("lblObjectCode")

        self.txtEditObjectcode = QtWidgets.QPlainTextEdit(self.centralwidget)
        self.txtEditObjectcode.setGeometry(QtCore.QRect(610, 40, 371, 281))
        self.txtEditObjectcode.setObjectName("txtEditObjectcode")

        self.cmdAssemble = QtWidgets.QPushButton(self.centralwidget, clicked = lambda: self.assemble())
        self.cmdAssemble.setGeometry(QtCore.QRect(410, 390, 75, 24))
        self.cmdAssemble.setObjectName("cmdAssemble")

        self.cmdLoadSourcecode = QtWidgets.QPushButton(self.centralwidget, clicked = lambda: self.loadSourcecode())
        self.cmdLoadSourcecode.setGeometry(QtCore.QRect(20, 330, 111, 24))
        self.cmdLoadSourcecode.setObjectName("cmdLoadSourcecode")

        self.cmdSaveSourcecode = QtWidgets.QPushButton(self.centralwidget, clicked = lambda: self.saveSourcecode())
        self.cmdSaveSourcecode.setGeometry(QtCore.QRect(150, 330, 111, 24))
        self.cmdSaveSourcecode.setObjectName("cmdSaveSourcecode")

        self.lblSourcecodeView = QtWidgets.QLabel(self.centralwidget)
        self.lblSourcecodeView.setGeometry(QtCore.QRect(20, 10, 101, 16))
        self.lblSourcecodeView.setObjectName("lblSourcecodeView")

        self.txtEditDebug = QtWidgets.QPlainTextEdit(self.centralwidget)
        self.txtEditDebug.setGeometry(QtCore.QRect(510, 420, 471, 321))
        self.txtEditDebug.setLineWrapMode(QtWidgets.QPlainTextEdit.LineWrapMode.NoWrap)
        self.txtEditDebug.setReadOnly(False)
        self.txtEditDebug.setObjectName("txtEditDebug")

        self.lblAssemblerView = QtWidgets.QLabel(self.centralwidget)
        self.lblAssemblerView.setGeometry(QtCore.QRect(20, 390, 101, 16))
        self.lblAssemblerView.setObjectName("lblAssemblerView")

        self.lblDebugView = QtWidgets.QLabel(self.centralwidget)
        self.lblDebugView.setGeometry(QtCore.QRect(510, 390, 101, 16))
        self.lblDebugView.setObjectName("lblDebugView")

        self.sciEditSourcecode = QsciScintilla(self.centralwidget)
        self.sciEditSourcecode.setGeometry(QtCore.QRect(20, 40, 581, 281))
        self.sciEditSourcecode.setFont(font)
        self.sciEditSourcecode.setUtf8(True)
        self.sciEditSourcecode.setMarginWidth(0, "0000")
        self.sciEditSourcecode.setCaretLineVisible(True)
        self.sciEditSourcecode.setCaretLineBackgroundColor(QtGui.QColor('lightblue'))
        self.sciEditSourcecode.setObjectName("sciEditSourcecode")

        AssemblerWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(AssemblerWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 22))
        self.menubar.setObjectName("menubar")
        AssemblerWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(AssemblerWindow)
        self.statusbar.setObjectName("statusbar")
        AssemblerWindow.setStatusBar(self.statusbar)

        self.retranslateUi(AssemblerWindow)
        QtCore.QMetaObject.connectSlotsByName(AssemblerWindow)

    def retranslateUi(self, AssemblerWindow):
        _translate = QtCore.QCoreApplication.translate
        AssemblerWindow.setWindowTitle(_translate("AssemblerWindow", "6502 Assembler"))
        self.cmdSaveObjectcode.setText(_translate("AssemblerWindow", "Download object code"))
        self.cmdSaveAsmToFile.setText(_translate("AssemblerWindow", "Save to File"))
        self.lblObjectCode.setText(_translate("AssemblerWindow", "Object Code:"))
        self.cmdAssemble.setText(_translate("AssemblerWindow", "Assemble"))
        self.cmdLoadSourcecode.setText(_translate("AssemblerWindow", "Load Sourcecode"))
        self.cmdSaveSourcecode.setText(_translate("AssemblerWindow", "Save Sourcecode"))
        self.lblSourcecodeView.setText(_translate("AssemblerWindow", "Sourcecode View:"))
        self.lblAssemblerView.setText(_translate("AssemblerWindow", "Assembler Listing:"))
        self.lblDebugView.setText(_translate("AssemblerWindow", "Debug Window:"))


    #
    # def saveSourcecode(self):
    #
    # Diese Methode speichert den Inhalt des QScintilla-Editorfensters ab
    # Das ist der (Assemblerquelltext)
    #

    def saveSourcecode(self):
        fileName, _ = QFileDialog.getSaveFileName(None, 
            "Save File", "", "All Files(*);;Assembler Source Files (*.asm)")

        if fileName:
            with open(fileName, 'w') as f:
                f.write(self.sciEditSourcecode.text())
    

    #
    # def loadSourcecode(self):
    # 
    # Dies ist die Behandlungsroutine für den Click auf den Button "Load Sourcecode"
    # 
     
    def loadSourcecode(self):
        # File Dialog liefert die angeklickte Datei zurück
        self.sourcecode.clear()
        fname = QFileDialog.getOpenFileName(None, "Open File", ".\\", "Assembler Source Files (*.asm)")
        if fname[0]:
            self.sciEditSourcecode.clear()
            with open(fname[0], "r") as input_file:
                for line in input_file:
                    self.sourcecode.append(line.strip("\r").strip("\n"))
                    self.sciEditSourcecode.append(line)
            # Die Breite der Spalte für die Zeilennummerierung festlegen (plus eine Extrastelle) 
            self.sciEditSourcecode.setMarginWidth(0, str(self.sciEditSourcecode.lines())+"0")



    #
    # def assemble(self):
    #
    # xxx mal drüber nachdenken:
    # xxx brauchen wir die Liste tatsächlich, oder kann
    # xxx der Assembler aus dem Editor gefüttert werden ?


    def assemble(self):
        # Wenn kein Quelltext geladen oder eingegeben wurde,
        # eine Warnmeldung ausgeben
        if self.sciEditSourcecode.length() == 0:
            msgBox = QMessageBox()
            msgBox.setWindowTitle("Warning")
            msgBox.setText("No sourcecode to assemble.\nPlease load or enter Code.")
            msgBox.exec()
        else:
            # Die Liste mit dem zu untersuchenden Quelltext löschen
            self.sourcecode.clear()
            # Den Quelltext aus dem Editor in die Liste laden
            for line in range(self.sciEditSourcecode.lines()):
                self.sourcecode.append(self.sciEditSourcecode.text(line).strip("\r").strip("\n"))
            # Inhalte aus dem Debugging-Fenster löschen
            self.txtEditDebug.clear()
            self.txtEditDebug.appendPlainText("Avengers... assemble!")
            self.txtEditDebug.appendPlainText("Starting Pass 1")

 
    def assemble(self):
        # Wenn kein Quelltext geladen oder eingegeben wurde,
        # eine Warnmeldung ausgeben
        if self.sciEditSourcecode.length() == 0:
            msgBox = QMessageBox()
            msgBox.setWindowTitle("Warning")
            msgBox.setText("No sourcecode to assemble.\nPlease load or enter Code.")
            msgBox.exec()
        else:
            # Die Liste mit dem zu untersuchenden Quelltext löschen
            self.sourcecode.clear()
            # Den Quelltext aus dem Editor in die Liste laden
            for line in range(self.sciEditSourcecode.lines()):
                self.sourcecode.append(self.sciEditSourcecode.text(line).strip("\r").strip("\n"))
            # Inhalte aus dem Debugging-Fenster löschen
            self.txtEditDebug.clear()
            self.txtEditDebug.appendPlainText("Starting Pass 1")
            self.txtEditDebug.appendPlainText("---------------")
            # die einzelnen Zeilen parsen
            line_number = 1
            for line in self.sourcecode:
                self.parse_codeline(line, line_number)
                line_number += 1

            # xxx wir dürfen nicht einfach die Zeile hochzählen
            # xxx Aus der Zeilennummer wird die Adresse berechnet
            # xxx Ein Kommentar oder auch ein Label verändern die Adresse nicht


    # 
    # def parse_codeline(self, codeline):
    # 
    # Get a single line of code wich may be:
    # 
    # start: lda #$50   ; blabla
    # 
    # 1) strip out the comment (if any)
    # 2) find the label (if any)
    # 3) find the opcodes and decode it
    # 4) find the operands and decode it (if any)
    # 5) finding the adressmode (has to do with finding the operand)
    #

    def parse_codeline(self, codeline, line_number):
        # 1) strip out the comment (if any)
        # return the codeline and the comment
        codeline, comment = self.cut_comments(codeline)
        # 2) find the label (if any)
        label, codeline = self.cut_label(codeline, line_number)
        # 3) find the opcodes 
        opcode, operand = self.cut_opcode(codeline)
        print("Opcode: " + opcode)
        print("Operand: " + operand)
        print()
        # 3a) decode the opcode
        opcode_1 = self.decode_opcode(opcode, line_number)
        # find the addressmode
        # we need two steps to do this.
        addressmodeformat, value = self.decode_addressmodeformat(operand, line_number)
        addressmode = self.decode_addressmode(opcode_1, addressmodeformat, value, line_number)
        print("Address Mode: " + addressmode)


    def decode_addressmode(self, opcode, modeformat, value, line_number):
        if (opcode in self.implicitopcodes) and (modeformat == "nothing"):
            return "implicit"
        if (opcode in self.accumulatoropcodes) and (modeformat == "nothing"):
            return "accumulator"
        if (opcode in self.accumulatoropcodes) and (modeformat == "accumulator"):
            return "accumulator"
        return "undetermined"



    #
    # def decode_addressmodeformat(self,operand, line_number):
    #
    # Find the address mode format as a first to step
    # to evaluate the address mode
    # Some mnemonics are ambiguous
    #

    def decode_addressmodeformat(self,operand, line_number):
        op_string = operand.replace(" ","")
        # a command could have no operand
        # RTS -> Implicit
        # ASL -> Accumulator
        # ASL A -> Accumulator
        # to resolve this ambiguity, we need two steps
        
        # Accumulator or Implicit
        if op_string == "":
            mode = "nothing"
            value = ""
        # Immediate    
        elif op_string[0] == "#":
            mode = "immediate"
            value = op_string[1]
        # Accumulator    
        elif (op_string == "a") or (op_string == "A"):
            mode = "accumulator"
            value = ""
        else:
            self.txtEditDebug.appendPlainText("Line " + str(line_number) + ":\tdecode_addressmode() did not understand address mode " + operand)
            mode = ""
            value = ""

        return (mode, value)



    #
    # def decode_opcode(self, op_code, line_number):
    #
    # Anhand der Liste der gültigen Opcodes wird der Quellcode untersucht
    # und die Opcodes in das Dictionary / Liste übernommen
    #

    def decode_opcode(self, op_code, line_number):
        opcode = op_code.upper()
        if opcode == "":
            self.txtEditDebug.appendPlainText("Line " + str(line_number) + ":\tcheck_opcode() returned NULL")
            return None
        # check for valid assembler command
        elif opcode in self.validopcodes:
            self.opcode_list.append((line_number,opcode))
            self.txtEditDebug.appendPlainText("Line " + str(line_number) + ":\tcheck_opcode() found " + opcode + " in opcode list")
            return opcode
        # check for db, dw, ddw, equ etc.
        elif opcode in self.validdirectives:
            self.opcode_list.appen((line_number, opcode))
            self.txtEditDebug.appendPlainText("Line " + str(line_number) + ":\tcheck_opcode() found " + opcode + " in directive list")
            return opcode
        else:
            self.txtEditDebug.appendPlainText("Line " + str(line_number) + ":\tcheck_opcode() returned no valid opcode")
            return None


    #
    # def cut_opcode(self, codeline):
    # 
    # This method tries to find an opcode in the line
    # and returns the opcode and the operand (if any)
    #

    def cut_opcode(self, codeline):
        # remove multiple whitespaces again
        line = codeline.strip()
        # used for validation
        noopcode = False
        nooperand = False

        # is the line empty?
        if len(line) == 0:
            noopcode = True
            nooperand = True
            opcodestring = ""
            operandstring = ""
        # if we have a " " in the line,
        # we should have an opcode and an operand
        elif " " in line:
            position = line.find(" ")
            opcodestring = line[:position].strip()
            operandstring = line[position+1:].strip()
            noopcode = False
            nooperand = False
        # no operand, could be a nop, plp, php, txa...
        else:
            opcodestring = line
            operandstring = ""
            noopcode = False
            nooperand = True

        # the line is empty, no opcode, no operand
        if noopcode:
            return "",""
        else:
            # we have no operand (command like "nop")
            if nooperand:
                return opcodestring, ""
            # we have an opcode and and operand
            else:
                return opcodestring, operandstring




    #
    # def cut_label(self, codeline):
    # 
    # This method tries to find a label in the provided line
    # and returns the label and the rest of the line (code)
    # 
         
    def cut_label(self, codeline, line_number):
        # check for any ":" which ends a label
        position = codeline.find(":")
        # if no ":" is found, the value is -1
        # return the string after the label and the label string 
        if (position == -1):
            # no comment, so return the code line
            return("", codeline)
        else:
            # remove multiple blanks
            label_string = codeline[:position].strip()
            # "remove" the ":" and multiple blanks
            code_string = codeline[position+1:].strip()
            position = label_string.find(' ')
            if position == -1:
                self.label_dict[label_string] = line_number
                self.label_list.append((line_number, label_string))

            self.txtEditDebug.appendPlainText("Line " + str(line_number) + ":\tLabel found: " + label_string)
            return(label_string, code_string.strip())



    #
    # def cut_comments(self, codeline):
    #
    # This method removes potential comments from the code line
    #

    def cut_comments(self, codeline):
        # check for any ";" which introduces a comment
        position = codeline.find(";")
        # if no ";" is found, the value is -1
        # return the string after the comment and the string before the comment
        if (position == -1):
            # no comment, so return the code line
            return(codeline,"")
        else:
            # return the code string and the comment
            # [:position] means chars from 0..position, where position is ";"
            # [position:] means chars from ";" to the end of line
            return(codeline[:position], codeline[position:])    


    def reset_vars(self):
        self.line_number = 1
        self.label_dict = dict()
        self.label_list = list()
